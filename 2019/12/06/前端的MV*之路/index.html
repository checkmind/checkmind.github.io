<!DOCTYPE html>
<html lang=>
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content>
  <meta name="keywords" content>
  
    <link rel="icon" href>
  
    
  <title>前端的MV*之路 | qqqdu&#39;s blog</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="/lib/jquery.fancybox.min.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
  <header>
  <div class="header-container">
    <a class='logo' href="/">
      <span>qqqdu's blog</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/about" class="item-link">关于</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">归档</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/tags" class="item-link">标签</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id='post'>
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>前端的MV*之路</h1>
          <div class='post-meta'>
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2019/12/06</time>
            
            
          </div>
          <h2 id="三段经历"><a href="#三段经历" class="headerlink" title="三段经历"></a>三段经历</h2><blockquote>
<p>我是从 16 年接触前端的，当时大二，经常干的事情是写一些简单有趣的交互，比如 打飞机/坦克大战/推箱子之类的。<br>这种东西经常一个脚本写一千多行就实现了。参数传来传去，回调调来调去。快乐极了。</p>
</blockquote>
<blockquote>
<p>17 年去一家古老的棋牌游戏公司做前端实习生，整个组就我一个前端，经常干的事情是写游戏抽奖页面，比如 转盘/抽纸牌之类的<br>交互简单字段少的页面。捧着 [ie tester] 兼容 ie6，页面切来切去，和后端模版套来套取，快乐极了。</p>
</blockquote>
<blockquote>
<p>18 年毕业了，在dxy做前端开发，前后端分离，交互复杂，接口繁多，这才用上了 Vue  全家桶。组件写来写去，请求来请求去，快乐极了。</p>
</blockquote>
<p>先总结以下这三段经历，</p>
<blockquote>
<p>16 年因为需求简单，不存在接口请求，所以代码填鸭在一个文件没什么毛病，当时就是 代码 写一个脚本里，频繁的操作 DOM</p>
</blockquote>
<blockquote>
<p>17 年需求更简单，虽然存在接口请求了，但数据量极其少且基本都在后端，前端仅有的状态基本放在全局，所以大量时间交给了页面切图和兼容。除了 DOM 操作变为 jquery，其余好像没什么变化。</p>
</blockquote>
<blockquote>
<p>18 年接口数量上来了，前后端分离，需要维护的状态多了，异步事件多了，交互复杂了，问题则出现了。接触组件，视图逻辑分离……</p>
</blockquote>
<p>我的需求在变化，前端也在不断变化，层出不穷的 MV* 到底是怎么变化的，它们解决了什么样的问题，一直困扰我。</p>
<p>我认为解答以上问题，得逐一了解每个库，看看它们各自解决了什么问题。</p>
<h2 id="Jquery-工具箱"><a href="#Jquery-工具箱" class="headerlink" title="Jquery 工具箱"></a>Jquery 工具箱</h2><p>Jquery 谁不知道呢，丰富的 api，简化 Dom 的操作，它就像一个齐全的工具箱。<br>比如下面这个例子。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"data"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">      url: <span class="string">''</span>,</span></span><br><span class="line">      success(res) &#123;</span><br><span class="line"><span class="javascript">        $(<span class="string">'#data'</span>).text(res.data)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>瞬间就实现了从接口到视图的转换。毫无疑问开发简单的 web 页面，用它是最快的。</p>
<p>但当我们的项目变得足够大时，仅仅靠 jquery 就力不从心了，因为它的视图和数据是耦合的。</p>
<h3 id="DOM-和-数据耦合的问题"><a href="#DOM-和-数据耦合的问题" class="headerlink" title="DOM 和 数据耦合的问题"></a>DOM 和 数据耦合的问题</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"year"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"input"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"submit"</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="javascript">      name: <span class="string">'qqqdu'</span>,</span></span><br><span class="line"><span class="javascript">      year: <span class="string">'24'</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    $(<span class="string">'#name'</span>).text(data.name)</span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#year'</span>).text(data.year)</span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#submit'</span>).click(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 请求1</span></span></span><br><span class="line"><span class="javascript">      $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">'URL1'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">          val: $(<span class="string">'#input'</span>).val()</span></span><br><span class="line">        &#125;,</span><br><span class="line">        success(res) &#123;</span><br><span class="line"><span class="javascript">          $(<span class="string">'#name'</span>).text(res.data.name)</span></span><br><span class="line"><span class="javascript">          $(<span class="string">'#year'</span>).text(res.data.year)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="comment">// some where...</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 请求2 也修改了视图</span></span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#some ID'</span>).click(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 请求1</span></span></span><br><span class="line"><span class="javascript">      $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">'URL2'</span>,</span></span><br><span class="line">        success(res) &#123;</span><br><span class="line"><span class="javascript">          $(<span class="string">'#name'</span>).text(res.data.name)</span></span><br><span class="line"><span class="javascript">          $(<span class="string">'#year'</span>).text(res.data.year)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上的例子，当代码执行时，会给 name 和 year 渲染默认值，当用户输入 input 后，点击了提交按钮，dom 将内容直接传给了请求，更改了后台的数据。然后请求返回，接口数据直接被更新在 dom #name。你一定注意到了，还有个 URL2 的请求，同样修改了 DOM #name。<br>假设你在调试这个页面，发现页面的值和请求 URL1 的返回值不同，你就困惑了，你得仔细找找代码里有哪些地方也修改了这个 DOM。如果代码量大，找起来肯定会头炸。<br>好的代码结构应该是怎么样的？我想它肯定不会让人困惑：</p>
<p>当你需要找事件绑定时，当你需要找数据在哪儿变更时，当你找视图更新时，你脑海中都应该有明确的方向。</p>
<p>那我们就从这三个方面入手，改造以上代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> app = &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    url: &#123;</span><br><span class="line">      <span class="string">'URL1'</span>: <span class="string">'https//xxx/URL1'</span>,</span><br><span class="line">      <span class="string">'URL2'</span>: <span class="string">'https//xxx/URL2'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      name: <span class="string">'qqqdu'</span>,</span><br><span class="line">      year: <span class="string">'24'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    setYear: <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.model.data.year = data</span><br><span class="line">      <span class="keyword">this</span>.view.renderText(<span class="keyword">this</span>.model.data)</span><br><span class="line">    &#125;,</span><br><span class="line">    setName: <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      data = <span class="string">'MR: '</span> + fullName</span><br><span class="line">      <span class="keyword">this</span>.model.data.name = data</span><br><span class="line">      <span class="keyword">this</span>.view.renderText(<span class="keyword">this</span>.model.data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(<span class="keyword">this</span>.model.data)</span><br><span class="line">    <span class="keyword">this</span>.view.bindDom()</span><br><span class="line">  &#125;,</span><br><span class="line">  view: &#123;</span><br><span class="line">    bindDom() &#123;</span><br><span class="line">      $(<span class="string">'#submit'</span>).click(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.controller.getURL1($(<span class="string">'#input'</span>).val())</span><br><span class="line">      &#125;)</span><br><span class="line">      $(<span class="string">'#some ID'</span>).click(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.controller.getURL2()</span><br><span class="line">      &#125;)</span><br><span class="line">      $(<span class="string">'#name'</span>).input(<span class="keyword">this</span>.controller.bindName)</span><br><span class="line">      $(<span class="string">'#year'</span>).input(<span class="keyword">this</span>.controller.bindYear)</span><br><span class="line">    &#125;,</span><br><span class="line">    renderText(options) &#123;</span><br><span class="line">      $(<span class="string">'#name'</span>).text(options.name)</span><br><span class="line">      $(<span class="string">'#year'</span>).text(options.year)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  controller: &#123;</span><br><span class="line">    bindName() &#123;</span><br><span class="line">      <span class="comment">// 业务处理</span></span><br><span class="line">      <span class="keyword">this</span>.setName(&#123;</span><br><span class="line">        name: $(<span class="keyword">this</span>).val()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    bindYear() &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        year: $(<span class="keyword">this</span>).val()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    getURL1(data) &#123;</span><br><span class="line">      <span class="comment">// 请求1</span></span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">        url: <span class="keyword">this</span>.model.url.URL1,</span><br><span class="line">        data: &#123;</span><br><span class="line">          val: data</span><br><span class="line">        &#125;,</span><br><span class="line">        success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 业务逻辑</span></span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">this</span>.setYear(res.data)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    getURL2() &#123;</span><br><span class="line">      <span class="comment">// 请求2</span></span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">        url: <span class="keyword">this</span>.model.url.URL2,</span><br><span class="line">        success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 业务逻辑</span></span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">this</span>.setData(res.data)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过这样的改造，看起来清晰多了：</p>
<ul>
<li>视图内所有的数据都来自于 app.data，引起数据变更的都在 controller 内，</li>
<li>所有与 DOM 渲染相关的，都在 View 内</li>
<li>所有与事件绑定相关的，都在 View 层，并且事件回调转给 controller 处理。</li>
</ul>
<p>到这一步你就知道我想说什么了。因为维护的数据过多，需要修改的 Dom 变多，二者耦合在一起难以维护和后期开发。<br>因此我们一般会将二者分层，加入中间层 controller 来给二者解耦。</p>
<p>这便是我们常说的 MVC 模式。</p>
<h3 id="前端-MVC"><a href="#前端-MVC" class="headerlink" title="前端 MVC"></a>前端 MVC</h3><blockquote>
<p>我们都知道 前端 MVC 是参考了后端 MVC 的实现。但因为前端业务场景和后端有差别，所以在实现时，也有差别。比如传统的后端 MVC，View 和 Model 层是不会有交互的，它们完全由 controller 完成交互，常常会引发 controller 臃肿问题。<br>不同的公司、不同的团队对于 臃肿 的处理方式也各不相同。比如我问了我们的后端：controller 又被分出来一个 service 层，用来做数据验证/业务处理……<br>对于前端而言，不同的 MVC 框架 的实现也各不相同，之前我一直纠结哪个框架属于 MVC，哪个不属于，后来我发现这种思考没多少益处。因为分层以及如何分层 都是要根据业务场景决定的。没有银弹。<br>在下文，MVC 都为下图。也只讲前端 MVC</p>
</blockquote>
<p>先来一张阮一峰大佬画的图吧</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020105.png" alt></p>
<p>这张图跟我们上面写的代码流程一致，当用户触发 view 时，view 将指令传给 controller，controller 修改 model，并由 model 触发 view 的修改。</p>
<p>因为整个流程是单向的，在维护类似这样的库时：</p>
<ul>
<li>View 变更了，一定是 Model 引起的。</li>
<li>Model 变更了，一定是 Controller 引起的。</li>
<li>Controller 变更了，一定是 View 引起的。</li>
</ul>
<p>带着这个思路去维护和开发，相比之前，肯定不会凌乱。并且更改 对应 层的代码时，不用担心影响其他层。</p>
<p>那前端开发，有没有好用的 mvc 框架呢？在这里我们就要引出 jquery 时代，比较火热的框架 <code>backbone</code> 了。</p>
<h2 id="这个时代名为：backbone"><a href="#这个时代名为：backbone" class="headerlink" title="这个时代名为：backbone"></a>这个时代名为：backbone</h2><p><img src="http://qqqdu.com/imgs/白胡子.jpg" alt></p>
<h3 id="backbone-的-MVC"><a href="#backbone-的-MVC" class="headerlink" title="backbone 的 MVC"></a>backbone 的 MVC</h3><p>相信有一部分前端们没听过这个框架，它在前端实现了 MVC，首先来看它的 MVC 分层</p>
<p>它给我们提供了 Model/Collection/View/Router</p>
<p>数据层：Models Collections(想像成 Models 的集合)<br>视图层：Views<br>逻辑层：Router(Controller)</p>
<p>同样的，放一张阮一峰大佬的Backbone架构图。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020108.png" alt="图片"></p>
<blockquote>
<ol>
<li>用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。</li>
</ol>
</blockquote>
<blockquote>
<p>来自：<a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html</a></p>
</blockquote>
<p>怎么回事儿，这么复杂，数据流不是单向的了，Views 可以作用于 Models，Models 也可以作用于 Views，这不是又回到之前了吗。（这里的 Controller，就是 backbone 的 Router）</p>
<p>在探究这个问题之前我们先把这张图修改一下，在不考虑路由变更的情况下，去掉 Router(Controller)。</p>
<p><img src="http://qqqdu.com/imgs/backbone.png" alt></p>
<p>也就是说，在去除了 Router 之后，backbone 的分层，只有 View 和 Model。 并且修改是双向的，那我们就得问一个问题：<strong>它们难道不会耦合吗？</strong></p>
<p>我们接着往下看。</p>
<h3 id="熟悉-backbone"><a href="#熟悉-backbone" class="headerlink" title="熟悉 backbone"></a>熟悉 backbone</h3><h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Input = Backbone.Model.extend(&#123;&#125;)</span><br><span class="line"><span class="keyword">const</span> input = <span class="keyword">new</span> Input(&#123;</span><br><span class="line">  background: <span class="string">'black'</span>,</span><br><span class="line">  value: <span class="string">'white'</span></span><br><span class="line">&#125;)</span><br><span class="line">input.set(&#123;</span><br><span class="line">  background: <span class="string">'white'</span></span><br><span class="line">&#125;)</span><br><span class="line">input.get(<span class="string">'background'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.model.bind(<span class="string">'change:value'</span>, () =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>通过 Backbone.Model.extend 可以构造一个 Model 类，在这个类实例化时，传入数据结构，通过实例的 set 方法来修改 model，通过 get 方法来获取 model。</p>
<p>并且 model 还可以绑定 change 事件，当数据变更时，会触发回调函数。</p>
<h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// View...</span></span><br><span class="line"><span class="keyword">const</span> DocumentRow = Backbone.View.extend(&#123;</span><br><span class="line">  model: input,</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.model.bind(<span class="string">'change:value'</span>, <span class="keyword">this</span>.render, <span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  events: &#123;</span><br><span class="line">    <span class="string">'input input'</span>: <span class="string">'changeValue'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  changeValue: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    input.set(&#123;</span><br><span class="line">      value: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = res.changed</span><br><span class="line">    $(<span class="string">'input'</span>).val(value)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> documents = <span class="keyword">new</span> DocumentRow()</span><br></pre></td></tr></table></figure>
<p>同样的，通过 Backbone.View.extend 可以构造 view 类，并且可选参数 model 可以绑定对应的 数据。在 initialize 时，可以监听 model 的事件变更，并且触发 render 函数，来<strong>手动</strong>更新视图。事件绑定写在 events 中，当用户修改了 input 时，会触发 changeValue 去更新 model。</p>
<p>完整的代码在：<a href="http://localhost:4000/template/backbone.html" target="_blank" rel="noopener">backbone DEMO</a></p>
<p>回到刚刚的问题， Model 和 View 是双向的？这样耦合吗？</p>
<h4 id="Model-和-View-耦合吗"><a href="#Model-和-View-耦合吗" class="headerlink" title="Model 和 View 耦合吗"></a>Model 和 View 耦合吗</h4><p>先来看看 Backbone 对于二者的介绍</p>
<blockquote>
<p>Models（模型）是任何 Javascript 应用的核心，包括数据交互及与其相关的大量逻辑： 转换、验证、计算属性和访问控制。<br>Views(视图) 这里可以写 HTML 或 CSS， 并可以配合使用任何 JavaScript 模板库（默认 underscore）。 一般的想法是将界面组织成逻辑视图，并由 Models 支持， Models 变化时，每一个视图都可以独立地进行更新</p>
</blockquote>
<p>如果按照这个思路去写业务，耦合应该是很小的。</p>
<p>但是，我们很可能会写成下面的样子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// views</span></span><br><span class="line">&#123;</span><br><span class="line">  changeValue: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = e.target.value</span><br><span class="line">    value = value.split(<span class="string">','</span>).join(<span class="string">'.'</span>)</span><br><span class="line">    value += <span class="string">' -&gt; good'</span></span><br><span class="line">    input.set(&#123;</span><br><span class="line">      value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当用户 修改了 input，触发了 changeValue 函数时<br>在 changeValue 中，对数据进行了加工，之后才修改了数据。这样会有两个问题，一是在项目中，类似的加工变多，View 会变得更加臃肿，二是，对于业务数据的加工，应该也属于 Model 层，如果放在这里，View 和 Model 又耦合了。</p>
<p>所以加工应该放在 Model 层，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// model</span></span><br><span class="line"><span class="keyword">const</span> InputModel = Backbone.Model.extend(&#123;</span><br><span class="line">  editValue(ev) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = ev.split(<span class="string">','</span>).join(<span class="string">'.'</span>)</span><br><span class="line">    value += <span class="string">' -&gt; good'</span></span><br><span class="line">    <span class="keyword">this</span>.set(&#123;</span><br><span class="line">      value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> input = <span class="keyword">new</span> InputModel(&#123;</span><br><span class="line">  background: <span class="string">'black'</span>,</span><br><span class="line">  value: <span class="string">'white'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// views</span></span><br><span class="line">&#123;</span><br><span class="line">  changeValue: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    input.editValue(e.target.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以实际开发中，我们要清楚的认识到，分层的用意，以及合理的把代码写在对应的 views/models 层上。不然分层就又没有意义了……</p>
<h4 id="Router（Controller）"><a href="#Router（Controller）" class="headerlink" title="Router（Controller）"></a>Router（Controller）</h4><p>再来看看它的 Router（Controller） 层。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> AppRouter = Backbone.Router.extend(&#123;</span><br><span class="line">  routes: &#123;</span><br><span class="line">    <span class="string">''</span>: <span class="string">'index'</span>,</span><br><span class="line">    list: <span class="string">'renderList'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  index: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    view.render(<span class="string">'index'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  renderList: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    view.render(<span class="string">'list'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> AppRouter()</span><br></pre></td></tr></table></figure>
<p>故名思意，Router 是处理路由逻辑的，它引用在 单页应用，监听 浏览器 URL <code>hash</code> 变化，当用户触发了变化，比如改变了 hash 值/回退/前进/刷新…<br><code>appRouter.routers</code> 就会执行对应的回调，从而触发 view 层更新。  </p>
<p>比如用户输入 <code>http://localhost/index.html</code>，则执行 <code>appRouter.index()</code> 方法，渲染 首页相关内容。  </p>
<p>然后用户跳转到 list，<code>http://localhost/index.html#list</code>，则执行 <code>appRouter.list()</code>方法，渲染 列表页相关内容。</p>
<p>因为 Router 只做简单的路由处理，这层会比较薄。  </p>
<h3 id="千年玄铁剑，手无缚鸡人"><a href="#千年玄铁剑，手无缚鸡人" class="headerlink" title="千年玄铁剑，手无缚鸡人"></a>千年玄铁剑，手无缚鸡人</h3><p>Backbone 是一款优秀的类库。  </p>
<p>模版渲染也 由开发者使用 underscore 这样的模版库实现。  </p>
<p>对于开发者，业务逻辑写在 View/Model 层都有可能，很容易造成上文的耦合问题。  </p>
<p>如何在 Model 二次变更后，让节点高效渲染也是个问题。是一次性更改所有相关 DOM，还是判断对应数据，做小范围更改？想想都麻烦。  </p>
<p>最重要的是，它依赖 jQuery, DOM 操作 还是交给开发者。极有可能在一个夜黑风高的加班夜，一个烦躁的小伙子在 Model 层随意操作 DOM～  </p>
<p>对于 Backbone 来说，应用在项目里的不确定性太高了，比如像我这种菜鸟很容易踩以上坑，当然它没落的原因肯定远不止此（<a href="https://www.jianshu.com/p/513cf989839c" target="_blank" rel="noopener">为什么认为Backbone是现代化前端框架的基石
</a>)。</p>
<p>但在 jquery 还算盛行的年代，它确实给我们提供了分离 Model 和 View 的解决方案，给我们提供了 单页面路由管理方案等等…相信很多维护公司老项目的同学们肯定能找到它的身影，甚至能看到，在很多年前，写下代码的人，在不断的斟酌，如何优雅的将代码填充在 Backbone 的四肢，让它稳健、坚固的支撑着大大小小的平台和应用。</p>
<blockquote>
<p>那个时代名为：Backbone</p>
</blockquote>
<h2 id="彻底拆解（MVP）"><a href="#彻底拆解（MVP）" class="headerlink" title="彻底拆解（MVP）"></a>彻底拆解（MVP）</h2><p>在 mvc 中，不管是一开始说的，C-M-V-C 流向，或者 backbone 的 M-V-M 流向，M 和 V 还是存在着某种联系，那能不能打破这种联系，让二者之间彻底的独立起来。<br>我们期望：<br>V 层只负责更新视图和用户事件监听，这样它可以不受 Model 的限制，自由的被 C 调用<br>M层只负责数据存储和业务数据加工，<br>让 C 来作为桥梁，M和V的通信只能通过 C   </p>
<p>我们先改造最开始 jQuery 的例子，实现这种流向。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> app = &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    url: &#123;</span><br><span class="line">      <span class="string">'URL1'</span>: <span class="string">'https//xxx/URL1'</span>,</span><br><span class="line">      <span class="string">'URL2'</span>: <span class="string">'https//xxx/URL2'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      name: <span class="string">'qqqdu'</span>,</span><br><span class="line">      year: <span class="string">'24'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    setYear: <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.model.data.year = data</span><br><span class="line">    &#125;,</span><br><span class="line">    setName: <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      data = <span class="string">'MR: '</span> + fullName</span><br><span class="line">      <span class="keyword">this</span>.model.data.name = data</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(<span class="keyword">this</span>.model.data)</span><br><span class="line">    <span class="keyword">this</span>.view.bindDom()</span><br><span class="line">  &#125;,</span><br><span class="line">  view: &#123;</span><br><span class="line">    bindDom() &#123;</span><br><span class="line">      $(<span class="string">'#submit'</span>).click(<span class="keyword">this</span>.controller.getURL1)</span><br><span class="line">      $(<span class="string">'#some ID'</span>).click(<span class="keyword">this</span>.controller.getURL2)</span><br><span class="line">      $(<span class="string">'#name'</span>).input(<span class="keyword">this</span>.controller.bindName)</span><br><span class="line">      $(<span class="string">'#year'</span>).input(<span class="keyword">this</span>.controller.bindYear)</span><br><span class="line">    &#125;,</span><br><span class="line">    renderText(options) &#123;</span><br><span class="line">      $(<span class="string">'#name'</span>).text(options.name)</span><br><span class="line">      $(<span class="string">'#year'</span>).text(options.year)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  controller: &#123;</span><br><span class="line">    bindName() &#123;</span><br><span class="line">      <span class="keyword">this</span>.model.setName($(<span class="keyword">this</span>).val())</span><br><span class="line">      <span class="keyword">this</span>.view.renderText(<span class="keyword">this</span>.model)</span><br><span class="line">    &#125;,</span><br><span class="line">    bindYear() &#123;</span><br><span class="line">      <span class="keyword">this</span>.model.setYear($(<span class="keyword">this</span>).val())</span><br><span class="line">      <span class="keyword">this</span>.view.renderText(<span class="keyword">this</span>.model)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改造起来很简单，直接将之前在 model 层触发的视图更新放在了 controller 层。这个 controller 形式上有点像一个中间人，所以这种模式被成为 MVP，P（Presenter）<br>还是放一张 阮一峰 大佬的图：<br><img src="http://qqqdu.com/imgs/mvp.png" alt="mvp">。  </p>
<p>MVP 彻底的分离了 View 和 Model 层，View 将 DOM 事件监听放在了 Presenter，Model 变更的触发以及视图更新的触发也放在了 Presenter，可以预料到，在事件的增多以及数据量变大后，Presenter 会变得臃肿。  </p>
<p>所以对于 MVP 来说，臃肿的 Presenter 又导致了不可维护性和复杂度。这好像又回到了解放前，Backbone 的 View 充满了业务逻辑 和 与 Model 层的交互变得臃肿。这样看好像前者没什么进步呀。  </p>
<p>让我们先想想，导致 Presenter 臃肿的原因是什么：  </p>
<ul>
<li>业务逻辑  </li>
<li>Model 的变更，需要手动同步到 View  </li>
<li>View 的变更，需要手动同步到 Model</li>
</ul>
<p>业务逻辑依然保留在 Presenter。我们能不能着手优化 第2/3点  </p>
<h2 id="解放双手（MVVM）"><a href="#解放双手（MVVM）" class="headerlink" title="解放双手（MVVM）"></a>解放双手（MVVM）</h2><p>在接下来的篇幅里，我们尝试实现 M-V V-M流程自动化。目的是不考虑性能，以最简单的方式实现这二者的双向绑定。  </p>
<h3 id="M-gt-V"><a href="#M-gt-V" class="headerlink" title="M -&gt; V"></a>M -&gt; V</h3><p>我们先忘掉成熟的 MVVM 或类 MVVM 库，如果一个数据变更了，想要实时反应在视图层，最简单的方式是什么？  </p>
<p>我能想到的就是开一个定时器，不断的监听数据，如果数据和对应视图的值不相等，则更新视图。  </p>
<h4 id="轮训监听"><a href="#轮训监听" class="headerlink" title="轮训监听"></a>轮训监听</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_dirtyCheck() &#123;</span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._dirtyCheck()</span><br><span class="line">    <span class="keyword">this</span>._render()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>requestAnimationFrame</code> 这个 api 根据系统来决定调用时机，一般和屏幕刷新频率有关，如果屏幕的刷新频率是 60HZ，那它会每 1000/60 ms 执行一次。相比 setTimeout 和 setInterval 这种宏任务来说，性能高不少。  </p>
<p>在这里，屏幕每刷新一次，就会执行 <code>_render</code> 方法。去判断是否更新视图。这种轮训机制，应该算最简单的实现数据监听的方法了吧。  </p>
<p>我们再实现下 <code>_render</code> 方法。  </p>
<h4 id="render-逻辑"><a href="#render-逻辑" class="headerlink" title="_render 逻辑"></a>_render 逻辑</h4><p>到这一步，我们要去对比数据和视图层的差别，不同则更新视图。那数据和视图势必要有一个绑定机制。我能想到最简单的方法就是给 dom 节点加属性来绑定。  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-mv</span>=<span class="string">"year"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-mv</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>假设我们的 model 结构是以下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> app = &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      name: <span class="string">'qqqdu'</span>,</span><br><span class="line">      year: <span class="string">'24'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那 <code>_render</code> 函数就可以这么实现，依然是用 jquery  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_render() &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = $(<span class="string">"[data-mv]"</span>)</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  vm.each(renderFn)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">renderFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> el = $(<span class="keyword">this</span>),</span><br><span class="line">        tagName = el[<span class="number">0</span>].tagName</span><br><span class="line">    <span class="keyword">const</span> key = el.data(<span class="string">'mv'</span>)</span><br><span class="line">    <span class="keyword">const</span> data = self.model.data[key]</span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/INPUT|SELECT/</span>.test(tagName)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(el.val() !== data) &#123;</span><br><span class="line">        el.val(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(el.text !== data) &#123;</span><br><span class="line">        el.text(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历拥有 <code>[data-mv]</code> 的节点，如果节点的 <code>[data-mv]</code>值 不等于 model 中的值，则改变节点的值。当然这里做了一个正则判断，如果是表单元素，则更新其 <code>value</code>，否则更新其 <code>innerText</code>。  </p>
<p>这样，我们用最简单的方式实现了 M -&gt; V 的更新。  </p>
<p>当然，2020年几乎所有的前端er都知道， Angular 用脏检测来做视图更新，Vue 用 <code>Object.defineProperty/Proxy</code>来做数据绑定。不管他们解决了什么其他问题或是优化了什么性能，我们都得知道，最开始他们为什么要这么做。</p>
<h3 id="V-gt-M"><a href="#V-gt-M" class="headerlink" title="V -&gt; M"></a>V -&gt; M</h3><p>至于视图层的变更引起 <code>Model</code> 的改变，我们平时接触的最多的就是 <code>input</code> 节点，那我们就尝试实现下一个 <code>input</code> 节点数据变更时，实时更新到 <code>Model</code>。  </p>
<p>同样的，我们得知道 input 和 哪个属性绑定，跟上一节一样。我们可以再定义一个属性 <code>data-mvvm</code>，当拥有这个属性的 <code>input</code> 节点change 时，我们直接将该节点的 value 赋值给 Model。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input data-mvvm="name"/&gt;</span></span><br><span class="line">_bindMVVM() &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = $(<span class="string">"[data-mvvm]"</span>)</span><br><span class="line">  vm.each(<span class="function"><span class="params">ev</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> el = $(vm[ev]),</span><br><span class="line">          tagName = el[<span class="number">0</span>].tagName,</span><br><span class="line">          key = el.data(<span class="string">'mvvm'</span>)</span><br><span class="line">    el[<span class="number">0</span>].addEventListener(<span class="string">'input'</span>, (ev) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.model.data[key] = ev.target.value</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.model.data, key)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>以上代码也很简单，监听了节点的 <code>input</code> 事件，并且在回调里赋值给 <code>model</code>。这样 v-&gt;m 的流程也自动化了。<br>但对于 <code>input</code> 节点而言，要绑定两个属性才能同时实现 <code>v-m</code> 和 <code>m-v</code>。这样有点麻烦，所以我们再改造一下 <code>_render</code> 函数。<br>以让它可以更新 <code>[data-mvvm]</code>属性。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_render() &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = $(<span class="string">"[data-mv]"</span>)</span><br><span class="line">  <span class="keyword">const</span> mvvm = $(<span class="string">"[data-mvvm"</span>);</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  vm.each(renderFn)</span><br><span class="line">  mvvm.each(renderFn)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">renderFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> el = $(<span class="keyword">this</span>),</span><br><span class="line">        tagName = el[<span class="number">0</span>].tagName</span><br><span class="line">    <span class="keyword">const</span> key = el.data(<span class="string">'mv'</span>) || el.data(<span class="string">'mvvm'</span>)</span><br><span class="line">    <span class="keyword">const</span> data = self.model.data[key]</span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/INPUT|SELECT/</span>.test(tagName)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(el.val() !== data) &#123;</span><br><span class="line">        el.val(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(el.text !== data) &#123;</span><br><span class="line">        el.text(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>从 MVP 到 MVVM，基本上就是我们刚刚做的改变了，视图层和数据层的交互本来需要 <code>Presenter</code> 作为中间人来手动更新，当我们在框架层面将这个流程自动化后，就变成了MVVM，而 Presenter 则被改名为 ViewModel</p>
<p>以我们写的 demo 举例子<br>View 层变为了 html 模版，它不再需要开发者操作 DOM，改由框架实现，目前唯一的职责是将 事件绑定回调 委托给了 ViewModel，事实上这点也可以放在模版去做，我们最开始不也是这么做的吗 <code>&lt;button onClick=&#39;tap&#39;/&gt;</code>。<br>对于 Model，是很纯粹的数据存储，也可以进行数据加工。<br>对于 <code>ViewModel</code>,承载更多的是业务逻辑，而非同步视图和数据。  </p>
<p>最终，我们的流向图变成以下：  </p>
<p><img src="http://qqqdu.com/imgs/mvvm.png" alt></p>
<p>完 ##</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://juejin.im/post/59fd94475188254115703461" target="_blank" rel="noopener">https://juejin.im/post/59fd94475188254115703461</a></p>
<p><a href="https://uinika.github.io/web/broswer/backbone.html" target="_blank" rel="noopener">https://uinika.github.io/web/broswer/backbone.html</a></p>
<p><a href="https://www.jianshu.com/p/6ef75d044731" target="_blank" rel="noopener">https://www.jianshu.com/p/6ef75d044731</a></p>

        </section>
    </article>
    
        
  </div>
  <aside>
    
    <div class="toc-container">
        <h1>目录</h1>
        <div class="content">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#三段经历"><span class="toc-number">1.</span> <span class="toc-text">三段经历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jquery-工具箱"><span class="toc-number">2.</span> <span class="toc-text">Jquery 工具箱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-和-数据耦合的问题"><span class="toc-number">2.1.</span> <span class="toc-text">DOM 和 数据耦合的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#前端-MVC"><span class="toc-number">2.2.</span> <span class="toc-text">前端 MVC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#这个时代名为：backbone"><span class="toc-number">3.</span> <span class="toc-text">这个时代名为：backbone</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#backbone-的-MVC"><span class="toc-number">3.1.</span> <span class="toc-text">backbone 的 MVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#熟悉-backbone"><span class="toc-number">3.2.</span> <span class="toc-text">熟悉 backbone</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Model"><span class="toc-number">3.2.1.</span> <span class="toc-text">Model</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View"><span class="toc-number">3.2.2.</span> <span class="toc-text">View</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Model-和-View-耦合吗"><span class="toc-number">3.2.3.</span> <span class="toc-text">Model 和 View 耦合吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Router（Controller）"><span class="toc-number">3.2.4.</span> <span class="toc-text">Router（Controller）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#千年玄铁剑，手无缚鸡人"><span class="toc-number">3.3.</span> <span class="toc-text">千年玄铁剑，手无缚鸡人</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#彻底拆解（MVP）"><span class="toc-number">4.</span> <span class="toc-text">彻底拆解（MVP）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解放双手（MVVM）"><span class="toc-number">5.</span> <span class="toc-text">解放双手（MVVM）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#M-gt-V"><span class="toc-number">5.1.</span> <span class="toc-text">M -&gt; V</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#轮训监听"><span class="toc-number">5.1.1.</span> <span class="toc-text">轮训监听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#render-逻辑"><span class="toc-number">5.1.2.</span> <span class="toc-text">_render 逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V-gt-M"><span class="toc-number">5.2.</span> <span class="toc-text">V -&gt; M</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM"><span class="toc-number">5.3.</span> <span class="toc-text">MVVM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用"><span class="toc-number">6.</span> <span class="toc-text">引用</span></a></li></ol>
        </div>
    </div>
    
  </aside>
</main>



  <footer>
  <div class="copyright">
    <div>
      &copy; 2021 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>&nbsp
    </div>
    <div>
      Theme by <a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank">Aath</a>
    </div>
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});
  
  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");
      
      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="/lib/jquery.fancybox.min.js"></script>


</body>
</html>
