<!DOCTYPE html>
<html lang=>
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content>
  <meta name="keywords" content>
  
    <link rel="icon" href>
  
    
  <title>你为什么看不懂源码之Vue 3.0 釜底抽薪 | qqqdu&#39;s blog</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="/lib/jquery.fancybox.min.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
  <header>
  <div class="header-container">
    <a class='logo' href="/">
      <span>qqqdu's blog</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/about" class="item-link">关于</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">归档</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/tags" class="item-link">标签</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id='post'>
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>你为什么看不懂源码之Vue 3.0 釜底抽薪</h1>
          <div class='post-meta'>
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2019/10/15</time>
            
            
          </div>
          <p>距离上一篇已经过去了好久……  </p>
<h2 id="先唠会儿嗑"><a href="#先唠会儿嗑" class="headerlink" title="先唠会儿嗑"></a>先唠会儿嗑</h2><p>之前在看 reactive 和 ref 时，总有两团黑雾笼罩着我们，一团是  <code>track</code>,一团是 <code>trigger</code>。  </p>
<p>二者都来自同一个文件，<code>effect.ts</code>。  </p>
<p>在 响应式数据 <code>get</code> 时，<code>track(target, OperationTypes.GET, key)</code>  </p>
<p>在 <code>set</code> 时 <code>trigger(target, OperationTypes.SET, key, extraInfo)</code>。  </p>
<p>不扯淡了，往下看吧</p>
<h2 id="从-effect-看起"><a href="#从-effect-看起" class="headerlink" title="从 effect 看起"></a>从 effect 看起</h2><p>接下来看 <code>ref.spec.ts</code> 中的一条用例 (ref 的流程比较简单，容易理解)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should be reactive'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> a = ref(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> dummy</span><br><span class="line">    <span class="comment">// 副作用包装下</span></span><br><span class="line">    effect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dummy = a.value</span><br><span class="line">    &#125;)</span><br><span class="line">    expect(dummy).toBe(<span class="number">1</span>)</span><br><span class="line">    a.value = <span class="number">2</span></span><br><span class="line">    expect(dummy).toBe(<span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>effect 接受一个函数，函数返回 dummy 变量，dummy 是响应式对象 a 的值。当改变了 a 的值时，dummy 也 重新计算了遍！  </p>
<p>这不就是 TMD 计算属性吗！接着往下看。  </p>
<p>首先，需要你人肉调试一遍，顺着 <code>effect</code> 函数的轨迹打上备注。  </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: () =&gt; T,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: ReactiveEffectOptions = EMPTY_OBJ</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 当然进不去</span></span><br><span class="line">  <span class="keyword">if</span> (isEffect(fn)) &#123;</span><br><span class="line">    fn = fn.raw</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 接下来去 `createReactiveEffect` 里面</span></span><br><span class="line">  <span class="keyword">const</span> effect = createReactiveEffect(fn, options)</span><br><span class="line">  <span class="comment">// lazy 是false，这里肯定会运行</span></span><br><span class="line">  <span class="keyword">if</span> (!options.lazy) &#123;</span><br><span class="line">    effect()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReactiveEffect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: () =&gt; T,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: ReactiveEffectOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 又用 reactiveEffect 包装了一层，进去看看</span></span><br><span class="line">  <span class="keyword">const</span> effect = <span class="function"><span class="keyword">function</span> <span class="title">reactiveEffect</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> run(effect, fn, args)</span><br><span class="line">  &#125; <span class="keyword">as</span> ReactiveEffect</span><br><span class="line">  <span class="comment">// 这里就是一堆参数</span></span><br><span class="line">  effect[effectSymbol] = <span class="literal">true</span></span><br><span class="line">  effect.active = <span class="literal">true</span></span><br><span class="line">  effect.raw = fn</span><br><span class="line">  effect.scheduler = options.scheduler</span><br><span class="line">  effect.onTrack = options.onTrack</span><br><span class="line">  effect.onTrigger = options.onTrigger</span><br><span class="line">  effect.onStop = options.onStop</span><br><span class="line">  effect.computed = options.computed</span><br><span class="line">  effect.deps = []</span><br><span class="line">  <span class="comment">// 返回的effect 函数会被 执行掉</span></span><br><span class="line">  <span class="keyword">return</span> effect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来到 <code>run</code> 函数了，这里用了一个巧妙的方法，我们单拿出来  </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">effect: ReactiveEffect, fn: <span class="built_in">Function</span>, args: <span class="built_in">any</span>[]</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里默认进不去</span></span><br><span class="line">  <span class="keyword">if</span> (!effect.active) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(...args)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里进去，刚开始肯定是 -1</span></span><br><span class="line">  <span class="keyword">if</span> (activeReactiveEffectStack.indexOf(effect) === <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// clear 操作，暂时不关心</span></span><br><span class="line">    cleanup(effect)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeReactiveEffectStack.push(effect)</span><br><span class="line">      <span class="comment">// 这里执行后，返回结果，fn 就是计算函数</span></span><br><span class="line">      <span class="keyword">return</span> fn(...args)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      activeReactiveEffectStack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面的 <code>try...finally</code>执行顺序换种写法是这样的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">activeReactiveEffectStack.push(effect)</span><br><span class="line"><span class="keyword">const</span> res = fn(...args)</span><br><span class="line">activeReactiveEffectStack.pop()</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>为什么要<code>try finally</code>呢？</p>
<blockquote>
<p>我想因为 <code>fn(...args)</code> 是用户写的函数。  它有可能报错，即使它报错了，也应该被 activeReactiveEffectStack.pop，一是 影响性能，二是 activeReactiveEffectStack 在 track 时，负责绑定 target 和 effect。</p>
</blockquote>
<p>继续往下看, <code>fn(...args)</code> 是 测试用例里的  </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; &#123;</span><br><span class="line">  dummy = a.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行 a.value 时会发生什么？当然是 ref 内部的 <code>get</code> 流程，而这个流程是会触发，<code>track(v, OperationTypes.GET, &#39;&#39;)</code></p>
<p>终于进入 <code>track</code> 时间  </p>
<h2 id="相恨见晚的-track"><a href="#相恨见晚的-track" class="headerlink" title="相恨见晚的 track"></a>相恨见晚的 <code>track</code></h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref.ts</span></span><br><span class="line">track(v, OperationTypes.GET, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// effect.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">type</span>: OperationTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">  key?: <span class="built_in">string</span> | symbol</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 默认 true</span></span><br><span class="line">  <span class="keyword">if</span> (!shouldTrack) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这时是有值的，在 try finally 流程中存入的</span></span><br><span class="line">  <span class="keyword">const</span> effect = activeReactiveEffectStack[activeReactiveEffectStack.length - <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">if</span> (effect) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span> === OperationTypes.ITERATE) &#123;</span><br><span class="line">      key = ITERATE_KEY</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.get(target)</span><br><span class="line">    <span class="keyword">if</span> (depsMap === <span class="built_in">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// targetMap 存入 key 为 ref 的 空 Map 对象。</span></span><br><span class="line">      targetMap.set(target, (depsMap = <span class="keyword">new</span> Map()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dep = depsMap.get(key!)</span><br><span class="line">    <span class="keyword">if</span> (dep === <span class="built_in">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// depsMap 存入 key  为 '' 的 空 Set 对象</span></span><br><span class="line">      depsMap.set(key!, (dep = <span class="keyword">new</span> Set()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!dep.has(effect)) &#123;</span><br><span class="line">      <span class="comment">// dep 存入 effect</span></span><br><span class="line">      dep.add(effect)</span><br><span class="line">      <span class="comment">// dep 入栈</span></span><br><span class="line">      effect.deps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; effect.onTrack) &#123;</span><br><span class="line">        effect.onTrack(&#123;</span><br><span class="line">          effect,</span><br><span class="line">          target,</span><br><span class="line">          <span class="keyword">type</span>,</span><br><span class="line">          key</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>track</code> 函数在对象被 set 时调用，它只进行了“记录”，记录的值有什么用呢？应该在 <code>trigger</code> 时会用到。  </p>
<p>当前我们最好能记一下 <code>track</code> 影响了哪些值。  </p>
<ul>
<li>全局的 targetMap，key 为 包装的 响应式对象的 <code>target</code>，值为 effect 对象  </li>
<li>effect对象的 <code>deps</code> 数组存了 <code>effect</code>，后面应该会有用到。</li>
</ul>
<h2 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a><code>trigger</code></h2><p>继续往下走，</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should be reactive'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> a = ref(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> dummy</span><br><span class="line">  <span class="comment">// 副作用包装下</span></span><br><span class="line">  effect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    dummy = a.value</span><br><span class="line">  &#125;)</span><br><span class="line">  expect(dummy).toBe(<span class="number">1</span>)</span><br><span class="line">  a.value = <span class="number">2</span></span><br><span class="line">  expect(dummy).toBe(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当 <code>a.value = 2</code> 时，肯定会调用 ref 对象的 set 方法，<br>这个时候就走 <code>trigger</code> 流程了:  <code>trigger(v, OperationTypes.SET, &#39;&#39;)</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">type</span>: OperationTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">  key?: <span class="built_in">string</span> | symbol,</span></span></span><br><span class="line"><span class="function"><span class="params">  extraInfo?: <span class="built_in">any</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 还记得吗，前面 set 过了</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (depsMap === <span class="built_in">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// never been tracked</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> effects = <span class="keyword">new</span> Set&lt;ReactiveEffect&gt;()</span><br><span class="line">  <span class="keyword">const</span> computedRunners = <span class="keyword">new</span> Set&lt;ReactiveEffect&gt;()</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> === OperationTypes.CLEAR) &#123;</span><br><span class="line">    <span class="comment">// collection being cleared, trigger all effects for target</span></span><br><span class="line">    depsMap.forEach(<span class="function"><span class="params">dep</span> =&gt;</span> &#123;</span><br><span class="line">      addRunners(effects, computedRunners, dep)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// schedule runs for SET | ADD | DELETE</span></span><br><span class="line">    <span class="comment">//addRunners 主要给 computedRunners 和 effects 添加值</span></span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="built_in">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      addRunners(effects, computedRunners, depsMap.get(key))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// also run for iteration key on ADD | DELETE</span></span><br><span class="line">    <span class="comment">// 这里为 数组 和 delete 服务，暂时不讨论</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span> === OperationTypes.ADD || <span class="keyword">type</span> === OperationTypes.DELETE) &#123;</span><br><span class="line">      <span class="keyword">const</span> iterationKey = <span class="built_in">Array</span>.isArray(target) ? <span class="string">'length'</span> : ITERATE_KEY</span><br><span class="line">      addRunners(effects, computedRunners, depsMap.get(iterationKey))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> run = <span class="function">(<span class="params">effect: ReactiveEffect</span>) =&gt;</span> &#123;</span><br><span class="line">    scheduleRun(effect, target, <span class="keyword">type</span>, key, extraInfo)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历执行effect 函数，computedRunners 为 计算属性服务，effects 为 单独调用 effect.ts 模块时服务。先谈后者。</span></span><br><span class="line">  computedRunners.forEach(run)</span><br><span class="line">  effects.forEach(run)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>trigger 方法主要从 全局 targetMap 对象中 拿出 target 对应的 effect</p>
<p>这两个函数是重点：<code>addRunners</code> 和 <code>scheduleRun</code>。  </p>
<p><code>addRunners</code> 将 depsMap 中的 effect 对象赋值给 <code>effects</code>，之后遍历 <code>effects</code> 执行 <code>run</code> 方法 <code>effects.forEach(run)</code>  </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addRunners</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  effects: Set&lt;ReactiveEffect&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  computedRunners: Set&lt;ReactiveEffect&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  effectsToAdd: Set&lt;ReactiveEffect&gt; | <span class="literal">undefined</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (effectsToAdd !== <span class="built_in">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    effectsToAdd.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (effect.computed) &#123;</span><br><span class="line">        computedRunners.add(effect)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        effects.add(effect)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleRun</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  effect: ReactiveEffect,</span></span></span><br><span class="line"><span class="function"><span class="params">  target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">type</span>: OperationTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="built_in">string</span> | symbol | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  extraInfo: <span class="built_in">any</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; effect.onTrigger) &#123;</span><br><span class="line">    effect.onTrigger(</span><br><span class="line">      extend(</span><br><span class="line">        &#123;</span><br><span class="line">          effect,</span><br><span class="line">          target,</span><br><span class="line">          key,</span><br><span class="line">          <span class="keyword">type</span></span><br><span class="line">        &#125;,</span><br><span class="line">        extraInfo</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前用例为 undefined</span></span><br><span class="line">  <span class="keyword">if</span> (effect.scheduler !== <span class="built_in">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    effect.scheduler(effect)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    effect()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>run 方法 调用了 <code>scheduleRun</code> 函数，直接运行了 <code>effect</code>，然后会走上文中的 <code>createReactiveEffect</code> 方法中的 <code>effect</code> 函数，直至再次触发以下函数，从而改变 dummy的值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">effect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  dummy = a.value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>简单的 <code>effect</code> 流程到这里就结束了。 我将其分为三个阶段：  </p>
<blockquote>
<p>绑定阶段：effect 函数会包装传入的 方法，将其变成一个 effect 对象，并在绑定阶段的最后执行一遍传入的 方法（初始化）。</p>
</blockquote>
<blockquote>
<p>收集阶段：effect 传入的方法内部，有响应式对象参与了计算，将触发 <code>get</code> 操作，会执行 <code>track</code> 方法，track 方法的重点是将响应式对象改变的<code>target</code> 与 绑定阶段的 <code>effect</code> 对象一一对应起来。这两个阶段是同步执行的（<code>activeReactiveEffectStack</code> 协调），值会存在全局的 <code>targetMap</code>。  </p>
</blockquote>
<blockquote>
<p>触发阶段：当 响应式对象 <code>set</code> 时，会触发 <code>trigger</code> 方法，它会从 <code>targetMap</code> 中拿到 target 对应的 <code>effects</code>，并遍历执行。</p>
</blockquote>
<h2 id="机智的-computed"><a href="#机智的-computed" class="headerlink" title="机智的 computed"></a>机智的 <code>computed</code></h2><p><code>effect</code> 就是这样了，但要直接用 <code>effect</code> 还是有点蛋疼。 </p>
<p>它默认反回了 <code>ReactiveEffect</code> 对象，我要这玩意儿干啥呢，我之前写计算属性，直接返回值就是 计算后的值。而现在：  </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dummy</span><br><span class="line"><span class="keyword">const</span> obj = reactive(&#123; prop: <span class="string">'value'</span> &#125;)</span><br><span class="line"></span><br><span class="line">effect(<span class="function"><span class="params">()</span> =&gt;</span> (dummy = obj.prop))</span><br></pre></td></tr></table></figure>
<p>每次都要定义一个额外变量 <code>dummy</code>，不仅麻烦，还很容易被外界篡改。</p>
<p>所以，终于到了机智的 <code>computed.ts</code> 文件，它的代码行数非常之少，八十几行，优秀（废话，核心功能 effect 都实现了。）。  </p>
<p>首先瞅瞅测试用例：  </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should return updated value'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = reactive&lt;&#123; foo?: <span class="built_in">number</span> &#125;&gt;(&#123;&#125;)</span><br><span class="line">    <span class="keyword">const</span> cValue = computed(<span class="function"><span class="params">()</span> =&gt;</span> value.foo)</span><br><span class="line">    expect(cValue.value).toBe(<span class="literal">undefined</span>)</span><br><span class="line">    value.foo = <span class="number">1</span></span><br><span class="line">    expect(cValue.value).toBe(<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>我直接把核心代码贴过来。compmuted 其实就是 对 effect 进一步封装</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">computed</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  getterOrOptions: (() =&gt; T) | WritableComputedOptions&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isReadonly = isFunction(getterOrOptions)</span><br><span class="line">  <span class="keyword">const</span> getter = isReadonly</span><br><span class="line">    ? <span class="function">(<span class="params">getterOrOptions <span class="keyword">as</span> (<span class="params">(<span class="params"></span>) =&gt; T</span>)</span>)</span></span><br><span class="line"><span class="function">    : (<span class="params">getterOrOptions <span class="keyword">as</span> WritableComputedOptions&lt;T&gt;</span>).<span class="params">get</span></span></span><br><span class="line"><span class="function">  // 测试环境会给出 <span class="params">computed</span> 属性不可 <span class="params">set</span> 的提示，正式环境会给一个 空函数</span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">setter</span> = <span class="params">isReadonly</span></span></span><br><span class="line"><span class="function">    ? __<span class="params">DEV__</span></span></span><br><span class="line"><span class="function">      ? <span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(<span class="string">'Write operation failed: computed value is readonly'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      : NOOP</span><br><span class="line">    : (getterOrOptions <span class="keyword">as</span> WritableComputedOptions&lt;T&gt;).set</span><br><span class="line">  <span class="comment">// 保证了在 get 时，只执行第一次 runner</span></span><br><span class="line">  <span class="keyword">let</span> dirty = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> value: T</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> runner = effect(getter, &#123;</span><br><span class="line">    <span class="comment">// effect 方法不会立即执行，在 get 时执行</span></span><br><span class="line">    lazy: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// mark effect as computed so that it gets priority during trigger</span></span><br><span class="line">    computed: <span class="literal">true</span>,</span><br><span class="line">    scheduler: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dirty = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [refSymbol]: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 导出了 runner 让 computed 可以被外部暂停</span></span><br><span class="line">    effect: runner,</span><br><span class="line">    <span class="keyword">get</span> value() &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">        value = runner()</span><br><span class="line">        dirty = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// When computed effects are accessed in a parent effect, the parent</span></span><br><span class="line">      <span class="comment">// should track all the dependencies the computed property has tracked.</span></span><br><span class="line">      <span class="comment">// This should also apply for chained computed properties.</span></span><br><span class="line">      trackChildRun(runner)</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> value(newValue: T) &#123;</span><br><span class="line">      setter(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先 computed 方法返回了 Ref 对象。<br>在 get 时，执行了 effect 方法，执行完毕 dirty 为 false，只有 响应式对象 trigger 后，dirty 才会为 true，在这中间，多次 get 值是一样的(因为响应式数据没有改变时，多次运行 effect 结果是一样的)<br>在 set 时，正式环境执行空方法，因为 computed 不支持 set。开发环境直接告警。  </p>
<blockquote>
<p>备注： 按照 computed 参数约束，是可以传入 <code>WritableComputedOptions</code> 对象，这样就支持 set 了，具体可参考测试用例：<code>should support setter</code></p>
</blockquote>
<h3 id="头大-“should-work-when-chained”"><a href="#头大-“should-work-when-chained”" class="headerlink" title="头大 “should work when chained”"></a>头大 “should work when chained”</h3><p>这个用例让我读了许久，很容易被绕进去，你最好用个小本本记录流程，然后不断的断点调试，直至清晰。  </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should work when chained'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> value = reactive(&#123; foo: <span class="number">0</span> &#125;)</span><br><span class="line">  <span class="keyword">const</span> c1 = computed(<span class="function"><span class="params">()</span> =&gt;</span> value.foo)</span><br><span class="line">  <span class="keyword">const</span> c2 = computed(<span class="function"><span class="params">()</span> =&gt;</span> c1.value + <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// expect(c2.value).toBe(1)</span></span><br><span class="line">  <span class="comment">// expect(c1.value).toBe(0)</span></span><br><span class="line">  value.foo++</span><br><span class="line">  expect(c2.value).toBe(<span class="number">2</span>)</span><br><span class="line">  <span class="comment">// expect(c1.value).toBe(1)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>其实用例在干什么很容易看出来， value 是一个响应式数据， c1作为 计算属性 引用了它，c2 作为计算属性引用了 c1，当 value.foo++ 时，这二者都要更新。c2 为 2， c1 为 1。</p>
<p>我大概描述下整个流程，希望能减轻（增加）你的痛苦。  </p>
<blockquote>
<p><code>const value = reactive({ foo: 0 })</code> -&gt; 创建响应式对象<br><code>const c1 = computed(() =&gt; value.foo)</code> -&gt; 创建计算属性 -&gt; 包装 effect 对象<br><code>const c2 = computed(() =&gt; c1.value + 1)</code>  -&gt; 创建计算属性 -&gt; 包装 effect 对象<br><code>value.foo++</code> -&gt; 响应式对象 get -&gt; set<br><code>expect(c2.value).toBe(2)</code> -&gt; c2.value -&gt;  c2 get -&gt; runner -&gt; activeReactiveEffectStack 存入 c2 effect -&gt; 执行 c2 计算函数 -&gt; 执行 c1.value -&gt; c1 get -&gt; runner -&gt; activeReactiveEffectStack 存入 c1 effect -&gt; 执行 c1 计算函数 -&gt; 调用 value 的 get 方法 -&gt; 触发 track -&gt; 绑定 effect 和 deep -&gt; activeReactiveEffectStack 弹出 c1 effect -&gt; <strong>执行 trackChildRun</strong> -&gt; 返回 c1 计算值 -&gt; activeReactiveEffectStack 弹出 c2 -&gt; 返回 c2 计算值  </p>
</blockquote>
<p>通过以上步骤，实现了计算属性的链式调用。  </p>
<p>这里重点注意我加粗的地方，<code>trackChildRun</code> 是 computed 中的方法。我打上了运行时备注：  </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// childRunner 是 c1 effect</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trackChildRun</span>(<span class="params">childRunner: ReactiveEffect</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此时 activeReactiveEffectStack 存在 c2 effect</span></span><br><span class="line">  <span class="keyword">const</span> parentRunner =</span><br><span class="line">    activeReactiveEffectStack[activeReactiveEffectStack.length - <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">if</span> (parentRunner) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childRunner.deps.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = childRunner.deps[i]</span><br><span class="line">      <span class="comment">// 绑定 dep 和 c2 effect，这里的 dep 对应着全局 targetMap 中的 dep</span></span><br><span class="line">      <span class="keyword">if</span> (!dep.has(parentRunner)) &#123;</span><br><span class="line">        dep.add(parentRunner)</span><br><span class="line">        parentRunner.deps.push(dep)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过 <code>trackChildRun</code> 的处理，响应式数据不仅绑定了 c1 还绑定了 c2，当下次响应式数据变更时，会遍历与其有关的 <code>dep</code> ，详见 <code>effect.ts</code> 的 <code>addRunners</code> 方法</p>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>终于将文章水完了，要是我也能用当下流行的量子波动阅读法来读源码就好了，溜了溜了……</p>

        </section>
    </article>
    
        
  </div>
  <aside>
    
    <div class="toc-container">
        <h1>目录</h1>
        <div class="content">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#先唠会儿嗑"><span class="toc-number">1.</span> <span class="toc-text">先唠会儿嗑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从-effect-看起"><span class="toc-number">2.</span> <span class="toc-text">从 effect 看起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#相恨见晚的-track"><span class="toc-number">3.</span> <span class="toc-text">相恨见晚的 track</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trigger"><span class="toc-number">4.</span> <span class="toc-text">trigger</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#机智的-computed"><span class="toc-number">5.</span> <span class="toc-text">机智的 computed</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#头大-“should-work-when-chained”"><span class="toc-number">5.1.</span> <span class="toc-text">头大 “should work when chained”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#未完待续"><span class="toc-number">6.</span> <span class="toc-text">未完待续</span></a></li></ol>
        </div>
    </div>
    
  </aside>
</main>



  <footer>
  <div class="copyright">
    <div>
      &copy; 2021 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>&nbsp
    </div>
    <div>
      Theme by <a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank">Aath</a>
    </div>
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});
  
  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");
      
      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="/lib/jquery.fancybox.min.js"></script>


</body>
</html>
